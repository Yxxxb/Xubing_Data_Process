You are an experienced programming instructor. Convert a single GitHub Pull Request (PR) into a **realistic, agent-style coding assessment**.

**Only output the question** between the required delimiters. Do **not** include any solutions, assets, metadata, or diffs.

## Inputs (provided below via placeholders)

* `{PR_JSON}`: Raw PR object (title, body, comments, commits, timestamps, etc.). + PR #57: [RFR] Changed the way the renaming works (proposal)
State: closed
Created: 2015-11-02T21:15:03Z
Merged: Not merged
Author: KittyGiraudel
URL: https://github.com/JuanPotato/Legofy/pull/57

Body:
This pull-request is only a suggestion, feel free to discard it if you do not agree with the way it works or the even the achieved goal.

So right now, the script renames the file by appending the `lego_` prefix to it, so that `path/to/file.jpg` becomes `path/to/lego_file.jpg`. It works great, except it doesnâ€™t preserve the file order when there are a lot of files in a folder, because of the filename prefix. My proposal would rename the file like so: `path/to/file.lego.jpg`, so that the conver...

Changes: +12/-2 lines in 1 files

* `{PATCH_UNIFIED_DIFF}`: Full unified diff of the PR. **For reference only. Do not reveal any of it.** + Patch (500 chars):
From 5f15fb553162c850f65a1d67f9b3d85a13fa4a7a Mon Sep 17 00:00:00 2001
From: Hugo Giraudel <hugo.giraudel@gmail.com>
Date: Mon, 2 Nov 2015 22:14:52 +0100
Subject: [PATCH] Changed the way the renaming works
MIME-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit

This pull-request is only a suggestion, feel free to discard it if you do not agree with the way it works or the even the achieved goal.

So right now, the renaming works like this `path/to/file.jpg` bec

* `{PATCH_METADATA}`: Files changed + per-file additions/deletions. + Files changed: 1
Lines added: 12
Lines deleted: 2
Net change: 10

Changed files (1):
  - legofy/__init__.py: +12/-2

* `{BASE_COMMIT_SHA}`: The base commit SHA the PR applies to. + f3408147b980187fc14dad53291ae0b96ca6fde5

* `{REPO_METADATA}`: Repo identifiers (owner/name/URLs). + Full name: Unknown/Unknown
Owner: Unknown
Name: Unknown
URL: https://github.com/Unknown/Unknown

* `{BASE_CODE_TAR_PATH}` or `{BASE_CODE_DIR}`: Base commit code bundle/path. + Base code directory: /data/xubing/oss_swe/swebench_sample_40k_commit_raw_code/JuanPotato#Legofy#pull#57/source_code
Total files in directory: 15
GitHub tree (base commit): https://github.com/Unknown/Unknown/tree/f3408147b980187fc14dad53291ae0b96ca6fde5

* `{ORACLE_FILES}` (optional): Original versions of the edited files at `{BASE_COMMIT_SHA}` for quoting **small context snippets** only. + Oracle files count: 1

Oracle files (showing first 3 file contents, truncated):

--- legofy/__init__.py ---
from __future__ import unicode_literals

from PIL import Image
from subprocess import call
import shutil
import sys
import os

# function that iterates over the gif's frames
def iter_frames(imageToIter):
    try:
        i = 0
        while 1:
            imageToIter.seek(i)
            imframe = imageToIter.copy()
            if i == 0:
                palette = imframe.getpalette()
            else:
                imframe.putpalette(palette)
            yield imframe
            i += 1
    ex...

All edited files in base commit:
  https://github.com/Unknown/Unknown/blob/f3408147b980187fc14dad53291ae0b96ca6fde5/legofy/__init__.py

* `{PROBLEM_STATEMENT}` (optional): If present in the PR; may be empty. + Problem statement: Not available (empty in SWE-Bench data)

* `{TEST_PATCH_UNIFIED_DIFF}` (optional): Whether tests were changed (reference only; **do not reveal code**). + Test patch: Not available (no tests were changed or test patch is empty)

* `{AVG_FILES}`, `{TOTAL_FILES}`, `{TOTAL_LINES}` (optional): Aggregate repo stats. + Total files: 13
Total lines: 2,578
Python files: 5
Python lines: 201

## Hard Rules

1. **No Leakage**: Do **not** quote, paraphrase, summarize, or expose any content from `{PATCH_UNIFIED_DIFF}` or `{TEST_PATCH_UNIFIED_DIFF}`.

2. **Grounding**: All requirements must be **strictly derived** from `{PR_JSON}` + code context at `{BASE_COMMIT_SHA}`. No hallucinated APIs/files/behaviors.

3. **Edit Scope**: The "Files to modify" list in the question must be a **subset of** `{PATCH_METADATA.changed_files}` and should reflect the actual loci of change.

4. **Context Snippets**: If helpful, you may include **small excerpts** from `{ORACLE_FILES}` to illustrate the **pre-change** context only (avoid large blocks). For large references, use link stubs:

   ```

   <github_code_start>https://github.com/Unknown/Unknown/blob/{BASE_COMMIT_SHA}/path/to/file.py#L100-L160</github_code_start>

   ```

5. **Verifiability**: Phrase acceptance criteria so that a grader could verify by applying a correct patch to `{BASE_COMMIT_SHA}` and running the project. Do **not** reveal expected code.

6. **Unsuitable PRs**: If inputs are insufficient (e.g., doc-only/binary-only changes, missing base code), output **only** `BAD_PR` inside the Question block.

## Output Format (produce **only** this block)

````

<|Question Begin|>

Title: {Concise, domain-relevant title}

Scenario (agent-style, production context):

- Briefly describe the real-world motivation and the subsystem involved, derived from {PR_JSON}.

- Keep it practical (e.g., configuration loading, IO pipeline, API contract fix).

Available Materials:

- Base commit: {BASE_COMMIT_SHA}

- Code bundle: {BASE_CODE_TAR_PATH} or {BASE_CODE_DIR}

- Repository: {REPO_METADATA.owner}/{REPO_METADATA.name}

- (Optional) Context excerpts (pre-change) from ORACLE_FILES:

  ```python

  # file: path/to/file.py @ {BASE_COMMIT_SHA}

  # short snippet showing current API/signature/usage relevant to the change

````

Or link stubs:

<github_code_start>[https://github.com/Unknown/Unknown/blob/{BASE_COMMIT_SHA}/path/to/file.py#L120-L168](https://github.com/Unknown/Unknown/blob/{BASE_COMMIT_SHA}/path/to/file.py#L120-L168)</github_code_start>

Your Task:

* Implement the required fix/feature by editing **only** these files:

  * path/to/fileA.py

  * path/to/fileB.json

    (All listed files must be a subset of {PATCH_METADATA.changed_files}.)

* Preserve public contracts unless the change is explicitly required by the scenario.

Functional Requirements:

* Bullet the concrete behaviors expected after the change (input/output, config keys, error handling, edge cases), reconstructed from {PR_JSON}.

* Avoid spoilers (no code, no diff lines, no exact identifiers beyond what exists at base).

Constraints:

* Performance/complexity expectations if implied by the PR (e.g., do not introduce O(N^2) in hot path).

* Backward compatibility or migration notes as applicable.

* Do not modify files outside the scope above.

How We Evaluate:

* Apply the candidate's patch to {BASE_COMMIT_SHA}.

* Run the minimal command(s) to exercise the change (e.g., `python main.py --config path/to/config.json`) and/or project tests if they exist.

* Success signals: specify observable outcomes (logs, CLI output, behavior) without revealing implementation.

Submission Format:

* Submit a unified diff patch that applies cleanly to {BASE_COMMIT_SHA}.

* Do not include compiled artifacts or large assets.

(If the PR is unsuitable or inputs insufficient, output BAD_PR.)

<|Question End|>

```

## Final Instruction

- Output **only** the `<|Question Begin|>…<|Question End|>` block.  

- Do **not** include any additional sections, notes, or explanations.
